name: VPS Ops (SSH)

on:
  workflow_dispatch:
    inputs:
      action:
        description: What to do on the VPS
        required: true
        default: doctor
        type: choice
        options:
          - doctor
          - install-proxy
          - restart-backend
          - backend-logs
          - check-http
      lines:
        description: Lines for logs (backend-logs)
        required: false
        default: "120"
      url:
        description: URL to check (check-http)
        required: false
        default: "https://versusversevault.com/api/health"
  push:
    branches: ["main"]

jobs:
  decide:
    runs-on: ubuntu-latest
    outputs:
      action: ${{ steps.decide.outputs.action }}
      lines: ${{ steps.decide.outputs.lines }}
      url: ${{ steps.decide.outputs.url }}
    steps:
      - name: Decide Action
        id: decide
        shell: bash
        run: |
          set -euo pipefail

          event="${GITHUB_EVENT_NAME}"
          action=""
          lines="120"
          url="https://versusversevault.com/api/health"

          if [ "${event}" = "workflow_dispatch" ]; then
            # Inputs exist only for workflow_dispatch, read them from the event payload to avoid quoting issues.
            action="$(jq -r '.inputs.action // "doctor"' "${GITHUB_EVENT_PATH}")"
            lines="$(jq -r '.inputs.lines // "120"' "${GITHUB_EVENT_PATH}")"
            url="$(jq -r '.inputs.url // "https://versusversevault.com/api/health"' "${GITHUB_EVENT_PATH}")"
          else
            # Auto-trigger only when the commit message explicitly asks for it.
            # Use one of:
            # - "vps:install-proxy"
            # - "vps:restart-backend"
            # - "vps:doctor"
            # - "vps:check-http"
            msg="$(jq -r '.head_commit.message // ""' "${GITHUB_EVENT_PATH}")"
            if echo "${msg}" | grep -qiE '(^|[[:space:]])vps:install-proxy([[:space:]]|$)'; then
              action="install-proxy"
            elif echo "${msg}" | grep -qiE '(^|[[:space:]])vps:restart-backend([[:space:]]|$)'; then
              action="restart-backend"
            elif echo "${msg}" | grep -qiE '(^|[[:space:]])vps:doctor([[:space:]]|$)'; then
              action="doctor"
            elif echo "${msg}" | grep -qiE '(^|[[:space:]])vps:check-http([[:space:]]|$)'; then
              action="check-http"
            else
              action=""
            fi
          fi

          echo "action=${action}" >> "${GITHUB_OUTPUT}"
          echo "lines=${lines}" >> "${GITHUB_OUTPUT}"
          echo "url=${url}" >> "${GITHUB_OUTPUT}"
          echo "Selected action: '${action}'"

  vps-ops:
    needs: decide
    if: ${{ needs.decide.outputs.action != '' }}
    runs-on: ubuntu-latest
    steps:
      - name: Setup SSH key
        shell: bash
        env:
          VPS_SSH_KEY: ${{ secrets.VPS_SSH_KEY }}
          VPS_SSH_KEY_B64: ${{ secrets.VPS_SSH_KEY_B64 }}
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_PORT: ${{ secrets.VPS_PORT }}
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          python3 - <<'PY'
          import base64
          import os
          import pathlib
          import re

          p = pathlib.Path.home() / ".ssh" / "deploy_key"

          key_b64 = (os.environ.get("VPS_SSH_KEY_B64") or "").strip()
          if key_b64:
            data = base64.b64decode(key_b64)
            if not data.endswith(b"\n"):
              data += b"\n"
            p.write_bytes(data)
            print("Wrote deploy_key from VPS_SSH_KEY_B64")
            raise SystemExit(0)

          raw = os.environ.get("VPS_SSH_KEY", "")
          if not raw.strip():
            raise SystemExit("VPS_SSH_KEY secret is empty. Provide VPS_SSH_KEY or VPS_SSH_KEY_B64.")

          raw = raw.replace("\r\n", "\n").replace("\r", "\n")
          if "\\n" in raw and "BEGIN" in raw and "\n" not in raw:
            raw = raw.replace("\\n", "\n")

          begin = re.search(r"-----BEGIN [A-Z0-9 ]+ PRIVATE KEY-----", raw)
          end = re.search(r"-----END [A-Z0-9 ]+ PRIVATE KEY-----", raw)
          if begin and end and end.end() > begin.start():
            raw = raw[begin.start():end.end()]

          if raw.lstrip().startswith("ssh-"):
            raise SystemExit("VPS_SSH_KEY looks like a PUBLIC key. Paste the PRIVATE key (BEGIN ... PRIVATE KEY).")

          key = raw.strip() + "\n"
          p.write_text(key)
          print("Wrote deploy_key from VPS_SSH_KEY")
          PY
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -p "${VPS_PORT}" -H "${VPS_HOST}" >> ~/.ssh/known_hosts

      - name: Doctor
        if: ${{ needs.decide.outputs.action == 'doctor' }}
        shell: bash
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_PORT: ${{ secrets.VPS_PORT }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_BACKEND_DIR: ${{ secrets.VPS_BACKEND_DIR }}
        run: |
          set -euo pipefail
          ssh -i ~/.ssh/deploy_key -p "${VPS_PORT}" -o BatchMode=yes "${VPS_USER}@${VPS_HOST}" \
            "VPS_BACKEND_DIR='${VPS_BACKEND_DIR:-}' bash -se" <<'SH'
          set -euo pipefail
          echo "== System =="
          uname -a || true
          cat /etc/os-release || true
          echo
          echo "== Network (listening) =="
          ss -ltnp | egrep ':80|:443|:5000|:2002|:2003|:2004|:2005' || true
          echo
          echo "== Web server vhosts (Webuzo Apache) =="
          /usr/local/apps/apache2/bin/httpd -S 2>&1 | head -n 140 || true
          echo
          echo "== PM2 =="
          command -v pm2 >/dev/null 2>&1 && pm2 status || echo "pm2 missing"
          echo
          echo "== Data (local db.json vs Mongo) =="
          BACKEND_DIR="${VPS_BACKEND_DIR:-/root/backend}"
          if [ ! -d "${BACKEND_DIR}" ]; then
            echo "Backend dir not found: ${BACKEND_DIR}"
            exit 0
          fi
          cd "${BACKEND_DIR}"
          if ! command -v node >/dev/null 2>&1; then
            echo "node missing"
            exit 0
          fi
          node --input-type=module - <<'NODE'
          import fs from 'fs/promises';
          import { MongoClient } from 'mongodb';

          const safePrint = (label, value) => {
            process.stdout.write(`${label}${value}\n`);
          };

          const parseEnvFile = (raw) => {
            const env = {};
            for (const line of raw.split(/\r?\n/)) {
              const trimmed = line.trim();
              if (!trimmed || trimmed.startsWith('#')) continue;
              const idx = trimmed.indexOf('=');
              if (idx <= 0) continue;
              const key = trimmed.slice(0, idx).trim();
              const value = trimmed.slice(idx + 1).trim();
              if (key) env[key] = value;
            }
            return env;
          };

          const deriveDbNameFromUri = (uri) => {
            const raw = String(uri || '').trim();
            if (!raw) return '';
            const match = raw.match(/^mongodb(?:\+srv)?:\/\/[^/]+\/([^?]*)/i);
            if (!match) return '';
            const candidate = String(match[1] || '').trim();
            if (!candidate) return '';
            try {
              return decodeURIComponent(candidate);
            } catch {
              return candidate;
            }
          };

          const tryRead = async (p) => {
            try {
              return await fs.readFile(p, 'utf8');
            } catch {
              return '';
            }
          };

          const localDbRaw = await tryRead('db.json');
          if (localDbRaw) {
            try {
              const json = JSON.parse(localDbRaw.replace(/^\uFEFF/, '').trim() || '{}');
              const users = Array.isArray(json.users) ? json.users.length : 0;
              const posts = Array.isArray(json.posts) ? json.posts.length : 0;
              const comments = Array.isArray(json.comments) ? json.comments.length : 0;
              safePrint('local.db.json users=', users);
              safePrint('local.db.json posts=', posts);
              safePrint('local.db.json comments=', comments);
            } catch (e) {
              safePrint('local.db.json parse_error=', e?.message || String(e));
            }
          } else {
            safePrint('local.db.json=', 'missing');
          }

          const envRaw = await tryRead('.env.production');
          const envFile = envRaw ? parseEnvFile(envRaw) : {};
          const merged = { ...process.env, ...envFile };
          const uri =
            merged.MONGO_URI ||
            merged.MONGODB_URI ||
            merged.MONGO_URL ||
            merged.DATABASE_URL ||
            '';

          safePrint('mongo.uri_present=', uri ? 'yes' : 'no');
          if (!uri) process.exit(0);

          const preferred = String(merged.MONGO_DB_NAME || '').trim();
          const derived = deriveDbNameFromUri(uri);
          const candidates = Array.from(
            new Set(
              [preferred, derived, 'versusversevault', 'geekfights']
                .map((v) => String(v || '').trim())
                .filter(Boolean)
            )
          );

          let client;
          try {
            client = new MongoClient(uri, { serverSelectionTimeoutMS: 4000 });
            await client.connect();
          } catch (e) {
            safePrint('mongo.connect_error=', e?.message || String(e));
            process.exit(0);
          }

          const keys = ['users', 'posts', 'comments', 'characters', 'votes', 'messages', 'chatMessages'];
          for (const dbName of candidates) {
            try {
              const db = client.db(dbName);
              const counts = {};
              for (const k of keys) {
                try {
                  counts[k] = await db.collection(k).estimatedDocumentCount();
                } catch {
                  counts[k] = null;
                }
              }
              safePrint(
                `mongo.db=${dbName} `,
                keys.map((k) => `${k}=${counts[k] ?? 'n/a'}`).join(' ')
              );
            } catch (e) {
              safePrint(`mongo.db=${dbName} error=`, e?.message || String(e));
            }
          }

          await client.close();
          NODE
          SH

      - name: Install Apache Proxy (/api, /share, /socket.io)
        if: ${{ needs.decide.outputs.action == 'install-proxy' }}
        shell: bash
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_PORT: ${{ secrets.VPS_PORT }}
          VPS_USER: ${{ secrets.VPS_USER }}
        run: |
          set -euo pipefail
          ssh -i ~/.ssh/deploy_key -p "${VPS_PORT}" -o BatchMode=yes "${VPS_USER}@${VPS_HOST}" "bash -se" <<'SH'
          set -euo pipefail

          DOMAIN="versusversevault.com"
          # Webuzo Apache uses IP-specific vhosts (see `httpd -S`), so use the public IP.
          IP="203.161.52.204"

          HTTPD="/usr/local/apps/apache2/bin/httpd"
          CONF_DIR="/usr/local/apps/apache2/etc/conf.d"
          MODULES_CNF="${CONF_DIR}/modules.cnf"
          DOCROOT="/usr/local/apps/apache2/www/htdocs"
          CERT_DIR="/etc/letsencrypt/live/${DOMAIN}"
          CERT_FULLCHAIN="${CERT_DIR}/fullchain.pem"
          CERT_PRIVKEY="${CERT_DIR}/privkey.pem"

          if [ ! -x "${HTTPD}" ]; then
            echo "ERROR: httpd not found at ${HTTPD}"
            exit 1
          fi

          if [ ! -d "${DOCROOT}" ]; then
            echo "ERROR: DOCROOT not found: ${DOCROOT}"
            exit 1
          fi

          if [ ! -f "${CERT_FULLCHAIN}" ] || [ ! -f "${CERT_PRIVKEY}" ]; then
            echo "ERROR: Let's Encrypt cert not found. Expected:"
            echo "  ${CERT_FULLCHAIN}"
            echo "  ${CERT_PRIVKEY}"
            exit 1
          fi

          echo "Enabling proxy modules (if present)..."
          if [ -f "${MODULES_CNF}" ]; then
            sed -i \
              -e 's/^#\\s*LoadModule\\s\\+proxy_module\\b/LoadModule proxy_module/' \
              -e 's/^#\\s*LoadModule\\s\\+proxy_http_module\\b/LoadModule proxy_http_module/' \
              -e 's/^#\\s*LoadModule\\s\\+proxy_wstunnel_module\\b/LoadModule proxy_wstunnel_module/' \
              -e 's/^#\\s*LoadModule\\s\\+headers_module\\b/LoadModule headers_module/' \
              "${MODULES_CNF}" || true
          fi

          CONF_FILE="${CONF_DIR}/zzz-${DOMAIN}.conf"
          if [ -f "${CONF_FILE}" ]; then
            cp -a "${CONF_FILE}" "${CONF_FILE}.bak.$(date +%s)"
          fi

          cat > "${CONF_FILE}" <<EOF
          # Managed by GitHub Actions (VPS Ops). Safe to edit, but changes may be overwritten.

          <VirtualHost ${IP}:80>
            ServerName ${DOMAIN}
            ServerAlias www.${DOMAIN}
            DocumentRoot ${DOCROOT}

            RewriteEngine On
            RewriteRule ^/\\.well-known/acme-challenge/ - [L]
            RewriteRule ^ https://%{HTTP_HOST}%{REQUEST_URI} [R=301,L]
          </VirtualHost>

          <VirtualHost ${IP}:443>
            ServerName ${DOMAIN}
            ServerAlias www.${DOMAIN}
            DocumentRoot ${DOCROOT}

            SSLEngine on
            SSLCertificateFile ${CERT_FULLCHAIN}
            SSLCertificateKeyFile ${CERT_PRIVKEY}

            ProxyPreserveHost On
            ProxyRequests Off
            RequestHeader set X-Forwarded-Proto "https"

            ProxyPass        /api/ http://127.0.0.1:5000/api/
            ProxyPassReverse /api/ http://127.0.0.1:5000/api/

            ProxyPass        /share/ http://127.0.0.1:5000/share/
            ProxyPassReverse /share/ http://127.0.0.1:5000/share/

            ProxyPass        /socket.io/ ws://127.0.0.1:5000/socket.io/
            ProxyPassReverse /socket.io/ ws://127.0.0.1:5000/socket.io/

            <Directory ${DOCROOT}>
              Options FollowSymLinks
              AllowOverride None
              Require all granted
            </Directory>

            RewriteEngine On
            RewriteCond %{REQUEST_URI} ^/(api|share|socket\\.io)(/|$) [NC]
            RewriteRule ^ - [L]
            RewriteCond %{REQUEST_FILENAME} -f [OR]
            RewriteCond %{REQUEST_FILENAME} -d
            RewriteRule ^ - [L]
            RewriteRule ^ /index.html [L]
          </VirtualHost>
          EOF

          # Ensure this vhost wins (avoid duplicate ServerName vhosts).
          LEGACY_VHOST="${CONF_DIR}/zz-${DOMAIN}.conf"
          if [ -f "${LEGACY_VHOST}" ]; then
            mv -f "${LEGACY_VHOST}" "${LEGACY_VHOST}.disabled.$(date +%s)"
          fi

          echo "Testing config..."
          "${HTTPD}" -t

          echo "Reloading httpd..."
          "${HTTPD}" -k graceful
          echo "OK"
          SH

      - name: Restart backend
        if: ${{ needs.decide.outputs.action == 'restart-backend' }}
        shell: bash
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_PORT: ${{ secrets.VPS_PORT }}
          VPS_USER: ${{ secrets.VPS_USER }}
        run: |
          set -euo pipefail
          ssh -i ~/.ssh/deploy_key -p "${VPS_PORT}" -o BatchMode=yes "${VPS_USER}@${VPS_HOST}" 'bash -se' <<'SH'
          set -euo pipefail
          if command -v pm2 >/dev/null 2>&1; then
            cd /root/backend
            export LD_LIBRARY_PATH=/root/backend/node_modules/@img/sharp-libvips-linux-x64/lib
            pm2 delete versusversevault-backend || true
            pm2 start server.js --name versusversevault-backend --update-env
            pm2 save || true
            pm2 status || true
            ss -ltnp | egrep ':5000' || true
          else
            echo "pm2 missing"
            exit 1
          fi
          SH

      - name: Backend logs
        if: ${{ needs.decide.outputs.action == 'backend-logs' }}
        shell: bash
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_PORT: ${{ secrets.VPS_PORT }}
          VPS_USER: ${{ secrets.VPS_USER }}
          LINES: ${{ needs.decide.outputs.lines }}
        run: |
          set -euo pipefail
          ssh -i ~/.ssh/deploy_key -p "${VPS_PORT}" -o BatchMode=yes "${VPS_USER}@${VPS_HOST}" "pm2 logs versusversevault-backend --lines ${LINES:-120} --nostream" || true

      - name: Check HTTP
        if: ${{ needs.decide.outputs.action == 'check-http' }}
        shell: bash
        env:
          URL: ${{ needs.decide.outputs.url }}
        run: |
          set -euo pipefail
          echo "Checking: ${URL}"
          curl -sS -D - "${URL}" -o /dev/null | head -n 40
